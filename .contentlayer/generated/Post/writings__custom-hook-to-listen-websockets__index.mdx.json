{
  "title": "Custom React hook for websocket updates",
  "date": "2021-05-11T00:00:00.000Z",
  "description": "With the power of React Context, create re-usable hooks to give your components the ability to listen to websocket events.",
  "banner": "banner.jpeg",
  "bannercaption": "Photo by Melanie Pongratz on Unsplash",
  "body": {
    "raw": "\nCreating reusable components is the main plus point when we are working with React. And hooks let us sprinkle powers to those components. Adding some state to the component, for example.\n\nIn this article, we will look at how we can create a custom hook, which powers the component to subscribe and unsubscribe to a websocket so that it can listen to all the events in a channel.\n\n> We will be using [socket.io](https://socket.io/docs/v4/) library. And we don't cover the steps involved to build a server which accepts socket connections.\n\nThe actual process of building a socket client is very simple. We have to create a socket and initialize it, and then add listeners to the channels which respond to events.\n\n```js\nconst socket = io('https://server-domain.com');\n\n// assuming details is the channel we want to listen to\nsocket.on('details', (...args) => {\n  // a callback function\n});\n```\n\nWhen it comes to doing this in React, we might have some decisions to make:\n\n- Do we store the socket instance in state?\n- Or a ref because we wont have to update it.\n- What if I have multiple components that want to use the socket? Maybe I store near the root and pass the socket via props to the components that need it.\n- A lot of passing props. Should I use context now?\n\nThat was exactly my thought process and this is solution I ended up with - we store the socket instance in the context and let the components subscribe using hooks.\n\n> The pattern we use here is inspired by Kent's [How to use Context effectively](https://kentcdodds.com/blog/how-to-use-react-context-effectively) post. You might want to have a look for extra clarity.\n\n## Creating the context\n\nLets kick things off by creating the context and exporting the Provider and the hooks so that the components can use them.\n\n```jsx\n// SocketProvider.jsx\n\nimport React from 'react';\nimport socketIOClient from 'socket.io-client';\n\nexport const SocketContext = React.createContext({ socket: null });\n```\n\nThat's our Context and we initialize the socket in the context with `null`.\n\nNow let's create the Provider, the component which is responsible for initializing the socket and putting it in the context so that the other components can use.\n\n```jsx\n// SocketProvider.jsx\n\nimport socketIOClient from 'socket.io-client';\n\nconst SocketProvider: React.FC = ({ children }) => {\n  // we use a ref to store the socket as it won't be updated frequently\n  const socket = useRef(socketIOClient('https://server-domain.com'));\n\n  // When the Provider mounts, initialize it ðŸ‘†\n  // and register a few listeners ðŸ‘‡\n\n  useEffect(() => {\n    socket.current.on('connect', () => {\n      console.log('SocketIO: Connected and authenticated');\n    });\n\n    socket.current.on('error', (msg: string) => {\n      console.error('SocketIO: Error', msg);\n    });\n\n    // Remove all the listeners and\n    // close the socket when it unmounts\n    return () => {\n      if (socket && socket.current) {\n        socket.current.removeAllListeners();\n        socket.current.close();\n      }\n    };\n  }, []);\n\n  return (\n    <SocketContext.Provider value={{ socket: socket.current }}>{children}</SocketContext.Provider>\n  );\n};\n\nexport default SocketProvider;\n```\n\nWe haven't added all the listeners yet. We need to let **components listen to the websocket updates**. So lets create a **custom hook**.\n\n```jsx\n\n// SocketProvider.jsx\n\nexport const useSocketSubscribe = (eventName, eventHandler) => {\n\t// Get the socket instance\n\tconst { socket } = useContext(SocketContext);\n\n\t// when the component, *which uses this hook* mounts,\n\t// add a listener.\n\tuseEffect(() => {\n\t\tconsole.log('SocketIO: adding listener', eventName);\n\t\tsocket.on(eventName, eventHandler);\n\n\t\t// Remove when it unmounts\n\t\treturn () \\=> {\n\t\t\tconsole.log('SocketIO: removing listener', eventName);\n\t\t\tsocket?.off(eventName, eventHandler);\n\t\t};\n\n\t// Sometimes the handler function gets redefined\n\t// when the component using this hook updates (or rerenders)\n\t// So adding a dependency makes sure the handler is\n\t// up to date!\n\t}, [eventHandler]);\n\n};\n```\n\n`useSocketSubscribe()` is our hook. And now, components can just import this hook and use it to add listeners to the global socket.\n\n```jsx\n// ExampleComponent.jsx\n\nimport React from 'react';\n\nimport { useSocketSubscribe } from './SocketProvder';\n\nexport default function ExampleComponent() {\n  const [someState, setSomeState] = useState('');\n\n  const handleSocketUpdate = (message) => {\n    setSomeState(message);\n  };\n\n  useSocketSubscribe('update', handleSocketUpdate);\n\n  return <div>{someState}</div>;\n}\n```\n\nThere is one last step. We wrap the complete App in the provider.\n\n```jsx\n// App.jsx\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport SocketProvider from './components/SocketProvider';\nimport ExampleComponent from './components/ExampleComponent';\n\nconst App = () => (\n  <SocketProvider>\n    {/* the actual app */}\n    <ExampleComponent />\n  </SocketProvider>\n);\n\nReactDOM.render(<App />, document.getElementById('app'));\n```\n\nThat's all. You now have a frontend where the components can choose to listen to the socket updates using the custom hook we built.\n\nHope that helps.\n\nHave a good day.\n",
    "code": "var Component=(()=>{var d=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of u(e))!k.call(n,s)&&s!==o&&c(n,s,{get:()=>e[s],enumerable:!(r=p(e,s))||r.enumerable});return n};var w=(n,e,o)=>(o=n!=null?d(m(n)):{},i(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),f=n=>i(c({},\"__esModule\",{value:!0}),n);var l=g((y,a)=>{a.exports=_jsx_runtime});var C={};v(C,{default:()=>S,frontmatter:()=>x});var t=w(l()),x={title:\"Custom React hook for websocket updates\",date:\"2021-05-11\",type:\"Post\",description:\"With the power of React Context, create re-usable hooks to give your components the ability to listen to websocket events.\",banner:\"banner.jpeg\",bannercaption:\"Photo by Melanie Pongratz on Unsplash\"};function h(n){let e=Object.assign({p:\"p\",blockquote:\"blockquote\",a:\"a\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Creating reusable components is the main plus point when we are working with React. And hooks let us sprinkle powers to those components. Adding some state to the component, for example.\"}),`\n`,(0,t.jsx)(e.p,{children:\"In this article, we will look at how we can create a custom hook, which powers the component to subscribe and unsubscribe to a websocket so that it can listen to all the events in a channel.\"}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"We will be using \",(0,t.jsx)(e.a,{href:\"https://socket.io/docs/v4/\",children:\"socket.io\"}),\" library. And we don't cover the steps involved to build a server which accepts socket connections.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"The actual process of building a socket client is very simple. We have to create a socket and initialize it, and then add listeners to the channels which respond to events.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const socket = io('https://server-domain.com');\n\n// assuming details is the channel we want to listen to\nsocket.on('details', (...args) => {\n  // a callback function\n});\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"When it comes to doing this in React, we might have some decisions to make:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Do we store the socket instance in state?\"}),`\n`,(0,t.jsx)(e.li,{children:\"Or a ref because we wont have to update it.\"}),`\n`,(0,t.jsx)(e.li,{children:\"What if I have multiple components that want to use the socket? Maybe I store near the root and pass the socket via props to the components that need it.\"}),`\n`,(0,t.jsx)(e.li,{children:\"A lot of passing props. Should I use context now?\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"That was exactly my thought process and this is solution I ended up with - we store the socket instance in the context and let the components subscribe using hooks.\"}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The pattern we use here is inspired by Kent's \",(0,t.jsx)(e.a,{href:\"https://kentcdodds.com/blog/how-to-use-react-context-effectively\",children:\"How to use Context effectively\"}),\" post. You might want to have a look for extra clarity.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Creating the context\"}),`\n`,(0,t.jsx)(e.p,{children:\"Lets kick things off by creating the context and exporting the Provider and the hooks so that the components can use them.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`// SocketProvider.jsx\n\nimport React from 'react';\nimport socketIOClient from 'socket.io-client';\n\nexport const SocketContext = React.createContext({ socket: null });\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"That's our Context and we initialize the socket in the context with \",(0,t.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Now let's create the Provider, the component which is responsible for initializing the socket and putting it in the context so that the other components can use.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`// SocketProvider.jsx\n\nimport socketIOClient from 'socket.io-client';\n\nconst SocketProvider: React.FC = ({ children }) => {\n  // we use a ref to store the socket as it won't be updated frequently\n  const socket = useRef(socketIOClient('https://server-domain.com'));\n\n  // When the Provider mounts, initialize it \\u{1F446}\n  // and register a few listeners \\u{1F447}\n\n  useEffect(() => {\n    socket.current.on('connect', () => {\n      console.log('SocketIO: Connected and authenticated');\n    });\n\n    socket.current.on('error', (msg: string) => {\n      console.error('SocketIO: Error', msg);\n    });\n\n    // Remove all the listeners and\n    // close the socket when it unmounts\n    return () => {\n      if (socket && socket.current) {\n        socket.current.removeAllListeners();\n        socket.current.close();\n      }\n    };\n  }, []);\n\n  return (\n    <SocketContext.Provider value={{ socket: socket.current }}>{children}</SocketContext.Provider>\n  );\n};\n\nexport default SocketProvider;\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We haven't added all the listeners yet. We need to let \",(0,t.jsx)(e.strong,{children:\"components listen to the websocket updates\"}),\". So lets create a \",(0,t.jsx)(e.strong,{children:\"custom hook\"}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`\n// SocketProvider.jsx\n\nexport const useSocketSubscribe = (eventName, eventHandler) => {\n\t// Get the socket instance\n\tconst { socket } = useContext(SocketContext);\n\n\t// when the component, *which uses this hook* mounts,\n\t// add a listener.\n\tuseEffect(() => {\n\t\tconsole.log('SocketIO: adding listener', eventName);\n\t\tsocket.on(eventName, eventHandler);\n\n\t\t// Remove when it unmounts\n\t\treturn () \\\\=> {\n\t\t\tconsole.log('SocketIO: removing listener', eventName);\n\t\t\tsocket?.off(eventName, eventHandler);\n\t\t};\n\n\t// Sometimes the handler function gets redefined\n\t// when the component using this hook updates (or rerenders)\n\t// So adding a dependency makes sure the handler is\n\t// up to date!\n\t}, [eventHandler]);\n\n};\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"useSocketSubscribe()\"}),\" is our hook. And now, components can just import this hook and use it to add listeners to the global socket.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`// ExampleComponent.jsx\n\nimport React from 'react';\n\nimport { useSocketSubscribe } from './SocketProvder';\n\nexport default function ExampleComponent() {\n  const [someState, setSomeState] = useState('');\n\n  const handleSocketUpdate = (message) => {\n    setSomeState(message);\n  };\n\n  useSocketSubscribe('update', handleSocketUpdate);\n\n  return <div>{someState}</div>;\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"There is one last step. We wrap the complete App in the provider.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`// App.jsx\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport SocketProvider from './components/SocketProvider';\nimport ExampleComponent from './components/ExampleComponent';\n\nconst App = () => (\n  <SocketProvider>\n    {/* the actual app */}\n    <ExampleComponent />\n  </SocketProvider>\n);\n\nReactDOM.render(<App />, document.getElementById('app'));\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"That's all. You now have a frontend where the components can choose to listen to the socket updates using the custom hook we built.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Hope that helps.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Have a good day.\"})]})}function b(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var S=b;return f(C);})();\n;return Component;"
  },
  "_id": "writings/custom-hook-to-listen-websockets/index.mdx",
  "_raw": {
    "sourceFilePath": "writings/custom-hook-to-listen-websockets/index.mdx",
    "sourceFileName": "index.mdx",
    "sourceFileDir": "writings/custom-hook-to-listen-websockets",
    "contentType": "mdx",
    "flattenedPath": "writings/custom-hook-to-listen-websockets"
  },
  "type": "Post",
  "slug": "/writings/custom-hook-to-listen-websockets"
}