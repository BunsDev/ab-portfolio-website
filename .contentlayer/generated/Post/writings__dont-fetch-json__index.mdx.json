{
  "title": "Don`t Fetch JSON",
  "date": "2019-02-05T00:00:00.000Z",
  "published": true,
  "description": "It is a small experiment to check whether you can directly get the `html` for the component instead of fetching the JSON data and populating it in the React Component.",
  "tags": "react,javascript",
  "banner": "banner.jpg",
  "body": {
    "raw": "\nWhy should you though? This is not intended if you have an API endpoint (backend) serving multiple types of clients(like mobile and web).\n\n> **Don't use this in production.** It's just an experiment.\n\nIt is a small experiment to check whether you can directly get the `html` for the component instead of fetching the JSON data and populating it in the React Component. Express is used for server rendered React output.\n\nGenerally in SSR, we have the routing logic in the React application, using `react-router` or some similar kind of library. The server (Express in our case) returns the complete React application for all routes and does not worry about routing.\n\n```javascript\napp.get('*', (req, res, next) => {\n  // ...\n  // res.send(renderToString(<App />)\n});\n```\n\nLet's build a special route, say `/getRenderedComponent`, to give the rendered HTML as a response, as a middleware.\n\n```javascript\n// middleware.js\nexports.renderedCompMiddleware = (req, res, next) => {\n  const items = ['Milk', 'Coffee'];\n  const html = `\n<h2>Server rendered component</h2>\n<ul>\n  ${items.map((item) => `<li>${item}</li>`)}\n</ul>\n`;\n\n  if (req.path.match(/\\/getcomp/)) {\n    res.send({ html });\n    return;\n  }\n  next();\n};\n\n// server.js\napp.get('*', renderedCompMiddleware, (req, res, next) => {\n  // ...\n  // res.send(renderToString(<App />)\n});\n```\n\nWe included it as a middleware, so the request will pass through it. (This might not be the correct way of doing this. We should have a separate route for this).\n\nAt the middleware, we render the HTML. We can even use `react-dom/renderToString` and render a React component to send as a response.\n\nThis response can be consumed in a React component easily. Something which can fetch and render HTML inside it will do the job. Like our `SSRComp`.\n\n```javascript\nimport React from 'react';\nimport { fetchComp } from './api';\n\nfunction createMarkup(text) {\n  return { __html: text };\n}\n\nclass SSRComp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      html: '<p>loading<p>',\n    };\n  }\n\n  componentDidMount() {\n    fetchComp().then((html) => this.setState({ html }));\n  }\n\n  render() {\n    const { html } = this.state;\n\n    return <div dangerouslySetInnerHTML={createMarkup(html)} />;\n  }\n}\n\nexport default SSRComp;\n```\n\n```javascript\nexport function fetchComp() {\n  return fetch('/getcomp')\n    .then((data) => data.json())\n    .then((comp) => comp.html)\n    .catch((error) => {\n      console.warn(error);\n      return null;\n    });\n}\n```\n\nI don't have an exact idea of where this can be put to a real production environment but was a successful fun experiment.\n\nThanks for reading through. Good day ðŸ‘‹\n",
    "code": "var Component=(()=>{var l=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!g.call(t,o)&&o!==r&&a(t,o,{get:()=>e[o],enumerable:!(i=p(e,o))||i.enumerable});return t};var w=(t,e,r)=>(r=t!=null?l(u(t)):{},c(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),b=t=>c(a({},\"__esModule\",{value:!0}),t);var d=f((R,s)=>{s.exports=_jsx_runtime});var S={};x(S,{default:()=>y,frontmatter:()=>j});var n=w(d()),j={title:\"Don`t Fetch JSON\",date:\"2019-02-05\",type:\"Post\",published:!0,description:\"It is a small experiment to check whether you can directly get the `html` for the component instead of fetching the JSON data and populating it in the React Component.\",tags:\"react,javascript\",banner:\"banner.jpg\"};function h(t){let e=Object.assign({p:\"p\",blockquote:\"blockquote\",strong:\"strong\",code:\"code\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Why should you though? This is not intended if you have an API endpoint (backend) serving multiple types of clients(like mobile and web).\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Don't use this in production.\"}),\" It's just an experiment.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It is a small experiment to check whether you can directly get the \",(0,n.jsx)(e.code,{children:\"html\"}),\" for the component instead of fetching the JSON data and populating it in the React Component. Express is used for server rendered React output.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Generally in SSR, we have the routing logic in the React application, using \",(0,n.jsx)(e.code,{children:\"react-router\"}),\" or some similar kind of library. The server (Express in our case) returns the complete React application for all routes and does not worry about routing.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`app.get('*', (req, res, next) => {\n  // ...\n  // res.send(renderToString(<App />)\n});\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's build a special route, say \",(0,n.jsx)(e.code,{children:\"/getRenderedComponent\"}),\", to give the rendered HTML as a response, as a middleware.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`// middleware.js\nexports.renderedCompMiddleware = (req, res, next) => {\n  const items = ['Milk', 'Coffee'];\n  const html = \\`\n<h2>Server rendered component</h2>\n<ul>\n  \\${items.map((item) => \\`<li>\\${item}</li>\\`)}\n</ul>\n\\`;\n\n  if (req.path.match(/\\\\/getcomp/)) {\n    res.send({ html });\n    return;\n  }\n  next();\n};\n\n// server.js\napp.get('*', renderedCompMiddleware, (req, res, next) => {\n  // ...\n  // res.send(renderToString(<App />)\n});\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"We included it as a middleware, so the request will pass through it. (This might not be the correct way of doing this. We should have a separate route for this).\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"At the middleware, we render the HTML. We can even use \",(0,n.jsx)(e.code,{children:\"react-dom/renderToString\"}),\" and render a React component to send as a response.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This response can be consumed in a React component easily. Something which can fetch and render HTML inside it will do the job. Like our \",(0,n.jsx)(e.code,{children:\"SSRComp\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import React from 'react';\nimport { fetchComp } from './api';\n\nfunction createMarkup(text) {\n  return { __html: text };\n}\n\nclass SSRComp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      html: '<p>loading<p>',\n    };\n  }\n\n  componentDidMount() {\n    fetchComp().then((html) => this.setState({ html }));\n  }\n\n  render() {\n    const { html } = this.state;\n\n    return <div dangerouslySetInnerHTML={createMarkup(html)} />;\n  }\n}\n\nexport default SSRComp;\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`export function fetchComp() {\n  return fetch('/getcomp')\n    .then((data) => data.json())\n    .then((comp) => comp.html)\n    .catch((error) => {\n      console.warn(error);\n      return null;\n    });\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"I don't have an exact idea of where this can be put to a real production environment but was a successful fun experiment.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Thanks for reading through. Good day \\u{1F44B}\"})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var y=v;return b(S);})();\n;return Component;"
  },
  "_id": "writings/dont-fetch-json/index.mdx",
  "_raw": {
    "sourceFilePath": "writings/dont-fetch-json/index.mdx",
    "sourceFileName": "index.mdx",
    "sourceFileDir": "writings/dont-fetch-json",
    "contentType": "mdx",
    "flattenedPath": "writings/dont-fetch-json"
  },
  "type": "Post",
  "slug": "/writings/dont-fetch-json"
}