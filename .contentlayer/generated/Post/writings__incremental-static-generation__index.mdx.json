{
  "title": "Incremental Static Generation",
  "date": "2021-04-13T00:00:00.000Z",
  "description": "SSG is not prefect, like all the other things in web development. And ISR makes SSG powerful but it has downsides too.",
  "banner": "banner.jpeg",
  "bannercaption": "Photo by Janko Ferlič on Unsplash",
  "body": {
    "raw": "\nWe know Static site generation (SSG) is awesome. We get to build the pages of the website in advance, which is while building the project, and then deploy it to a hosting provider like S3, GitHub pages, Netlify or Vercel. Some providers put a CDN on the front which makes accessing static pages very fast. ⚡️\n\n## This comes with some downsides though\n\nWhen ever you have a new page or changed content of a page, you'd need to rebuild the project and redeploy. For example, in our case, considering our podcast's website has a page for each episode, we need to redeploy after we release a new podcast episode. This adds friction to the content creation process.\n\nModern hosting providers have become powerful now. Netlify or Vercel give you a webhook, which can be pinged to trigger a new build. Well, this at least makes the process a little easy by not having to login to you provider's dashboard, navigating to your project and triggering a rebuild.\n\n> Trigger a build using iOS Shortcut\n>\n> ![ios-shortcut](shortcut.png)\n\nIf we use Gatsby to build the website, then it even intelligently builds only the pages that have changed. Incremental builds they call it. We'd need to trigger a build though.\n\n> If we deploy on Netlify/Vercel and connect Git, a redeploy gets triggered whenever a new commit is pushed. That is good when your content lives locally in the repo. But when it comes from an external source, we'd have to do it manually.\n\n## Enter ISR\n\n_ISR is short for Incremental Static Regeneration._\n\nISR gives few SSR benefits to SSG. _Wow, that's a good line, I should tweet it. You should retweet it maybe :p_\n\nhttps://twitter.com/aravindballa/status/1379990610552135682?s=21\n\nLet me explain that now. As the name says, ISR regenerates the pages after every visit. So the first visit to the page has old data, then it rebuilds that particular page in the background and serves it from the next time. You don't loose the magic of SSG here, which looking at content instantly and not waiting for the content to come.\n\n> I talk about scenarios with NextJS below and that apply only when we deploy on Vercel.\n\nNextJS framework has this feature built into it. It takes a parameter called `revalidate` in `getStaticProps()` method to see whether that page needs to be ISR and it rebuilds it incrementally.\n\n---\n\nThere one more feature in NextJS which is quite awesome. **Fallback pages**. We generally have all the pages built in advance if we use SSG. But in this case, we can specify `fallback: true` for lazy building. After the site has been deployed, it does it on the fly. _Isn't that cool!_\n\nThis actually adds superpowers to SSG. I talked about updating our podcast episode after every new release, right? Well, this would enable us to just fetch the page after a release.\n\n---\n\n## Is this perfect?\n\nWell, not really. We do sacrifice the first visit. First visit still sees the old data and then it refetches.\n\n**Should you use it over SSG?**\n\nDefinetly no. In some case, it is better to see old data instead of stale data first and new data later. Or always new data where one would choose SSR.\n\nFor data that isn't updated very frequently, but not always the same is a good fit. For example a page which fetches highlights of book. It's okay if the first visit see few less highlights.\n\nThat concludes this big post. Thanks for reading, have a good day!\n",
    "code": "var Component=(()=>{var c=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var i in e)a(n,i,{get:e[i],enumerable:!0})},s=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!w.call(n,o)&&o!==i&&a(n,o,{get:()=>e[o],enumerable:!(r=p(e,o))||r.enumerable});return n};var m=(n,e,i)=>(i=n!=null?c(u(n)):{},s(e||!n||!n.__esModule?a(i,\"default\",{value:n,enumerable:!0}):i,n)),y=n=>s(a({},\"__esModule\",{value:!0}),n);var l=f((j,h)=>{h.exports=_jsx_runtime});var I={};b(I,{default:()=>k,frontmatter:()=>S});var t=m(l()),S={title:\"Incremental Static Generation\",date:\"2021-04-13\",type:\"Post\",description:\"SSG is not prefect, like all the other things in web development. And ISR makes SSG powerful but it has downsides too.\",banner:\"banner.jpeg\",bannercaption:\"Photo by Janko Ferli\\u010D on Unsplash\"};function d(n){let e=Object.assign({p:\"p\",h2:\"h2\",blockquote:\"blockquote\",img:\"img\",em:\"em\",code:\"code\",hr:\"hr\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"We know Static site generation (SSG) is awesome. We get to build the pages of the website in advance, which is while building the project, and then deploy it to a hosting provider like S3, GitHub pages, Netlify or Vercel. Some providers put a CDN on the front which makes accessing static pages very fast. \\u26A1\\uFE0F\"}),`\n`,(0,t.jsx)(e.h2,{children:\"This comes with some downsides though\"}),`\n`,(0,t.jsx)(e.p,{children:\"When ever you have a new page or changed content of a page, you'd need to rebuild the project and redeploy. For example, in our case, considering our podcast's website has a page for each episode, we need to redeploy after we release a new podcast episode. This adds friction to the content creation process.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Modern hosting providers have become powerful now. Netlify or Vercel give you a webhook, which can be pinged to trigger a new build. Well, this at least makes the process a little easy by not having to login to you provider's dashboard, navigating to your project and triggering a rebuild.\"}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Trigger a build using iOS Shortcut\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"shortcut.png\",alt:\"ios-shortcut\"})}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"If we use Gatsby to build the website, then it even intelligently builds only the pages that have changed. Incremental builds they call it. We'd need to trigger a build though.\"}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsx)(e.p,{children:\"If we deploy on Netlify/Vercel and connect Git, a redeploy gets triggered whenever a new commit is pushed. That is good when your content lives locally in the repo. But when it comes from an external source, we'd have to do it manually.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Enter ISR\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.em,{children:\"ISR is short for Incremental Static Regeneration.\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"ISR gives few SSR benefits to SSG. \",(0,t.jsx)(e.em,{children:\"Wow, that's a good line, I should tweet it. You should retweet it maybe :p\"})]}),`\n`,(0,t.jsx)(e.p,{children:\"https://twitter.com/aravindballa/status/1379990610552135682?s=21\"}),`\n`,(0,t.jsx)(e.p,{children:\"Let me explain that now. As the name says, ISR regenerates the pages after every visit. So the first visit to the page has old data, then it rebuilds that particular page in the background and serves it from the next time. You don't loose the magic of SSG here, which looking at content instantly and not waiting for the content to come.\"}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsx)(e.p,{children:\"I talk about scenarios with NextJS below and that apply only when we deploy on Vercel.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"NextJS framework has this feature built into it. It takes a parameter called \",(0,t.jsx)(e.code,{children:\"revalidate\"}),\" in \",(0,t.jsx)(e.code,{children:\"getStaticProps()\"}),\" method to see whether that page needs to be ISR and it rebuilds it incrementally.\"]}),`\n`,(0,t.jsx)(e.hr,{}),`\n`,(0,t.jsxs)(e.p,{children:[\"There one more feature in NextJS which is quite awesome. \",(0,t.jsx)(e.strong,{children:\"Fallback pages\"}),\". We generally have all the pages built in advance if we use SSG. But in this case, we can specify \",(0,t.jsx)(e.code,{children:\"fallback: true\"}),\" for lazy building. After the site has been deployed, it does it on the fly. \",(0,t.jsx)(e.em,{children:\"Isn't that cool!\"})]}),`\n`,(0,t.jsx)(e.p,{children:\"This actually adds superpowers to SSG. I talked about updating our podcast episode after every new release, right? Well, this would enable us to just fetch the page after a release.\"}),`\n`,(0,t.jsx)(e.hr,{}),`\n`,(0,t.jsx)(e.h2,{children:\"Is this perfect?\"}),`\n`,(0,t.jsx)(e.p,{children:\"Well, not really. We do sacrifice the first visit. First visit still sees the old data and then it refetches.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:\"Should you use it over SSG?\"})}),`\n`,(0,t.jsx)(e.p,{children:\"Definetly no. In some case, it is better to see old data instead of stale data first and new data later. Or always new data where one would choose SSR.\"}),`\n`,(0,t.jsx)(e.p,{children:\"For data that isn't updated very frequently, but not always the same is a good fit. For example a page which fetches highlights of book. It's okay if the first visit see few less highlights.\"}),`\n`,(0,t.jsx)(e.p,{children:\"That concludes this big post. Thanks for reading, have a good day!\"})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var k=v;return y(I);})();\n;return Component;"
  },
  "_id": "writings/incremental-static-generation/index.mdx",
  "_raw": {
    "sourceFilePath": "writings/incremental-static-generation/index.mdx",
    "sourceFileName": "index.mdx",
    "sourceFileDir": "writings/incremental-static-generation",
    "contentType": "mdx",
    "flattenedPath": "writings/incremental-static-generation"
  },
  "type": "Post",
  "slug": "/writings/incremental-static-generation"
}