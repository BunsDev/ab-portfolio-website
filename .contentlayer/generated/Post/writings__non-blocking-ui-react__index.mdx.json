{
  "title": "Non blocking updates in React",
  "date": "2019-07-01T00:00:00.000Z",
  "published": true,
  "description": "Sometimes, a few updates/computations take up a lot of time. They block the UI from updating, which makes it look as if things are slow.",
  "tags": "react,javascript,webworkers",
  "banner": "banner.jpg",
  "body": {
    "raw": "\nSometimes, a few updates/computations take up a lot of time. They block the UI from updating, which makes it look as if things are slow. I am not talking about asynchronous data fetches which take time.\n\n> TL DR; We will be using web workers as a solution along with Hooks.\n\nConsider this for example\n\n```javascript\n// Codesandbox - https://codesandbox.io/s/admiring-pond-ixp59\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst fib = (i) => (i <= 1 ? i : fib(i - 1) + fib(i - 2));\n\nfunction App() {\n  const [value, setValue] = React.useState('');\n  const [length, setLength] = React.useState(0);\n\n  // whenever `value` changes\n  React.useEffect(() => {\n    // we calculate the fibonnaci of the length of input * 5\n    const result = fib(value.length * 5);\n    setLength(result);\n  }, [value]);\n\n  const handleChange = async (e) => {\n    const { value } = e.target;\n    setValue(value);\n  };\n  return (\n    <div className=\"App\">\n      <h1>Hello CodeSandbox</h1>\n      <h2>Start editing to see some magic happen!</h2>\n      <input value={value} onChange={handleChange} />\n      <p>{length}</p>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App />, rootElement);\n```\n\nWhen we enter the input here, it takes time to update. And it waits for the update to show up until,\ntill the result calculation is not finished. Fibonacci for large numbers is expensive.\nIt even freezes your browser tab if the input is long.\n\nDo we have a solution to this? Can we some how **off-load** this computation from the main thread?\n_(Why is he talking about threads in javascript?)_\n\n## Web Workers\n\nWeb workers act as threads which are handled/processed by our browser. We can start a worker as a thread and communicate with it in a particular way. React is after all Javascript UI library, and we are running it in the browser, so why not?\n\nThis is the worker, which has to be statically served. (Put in `public` folder)\n\n```javascript\n// thread.worker.js\nconst fib = (i) => (i <= 1 ? i : fib(i - 1) + fib(i - 2));\n\nself.addEventListener('message', ({ data }) => {\n  let { type, payload } = data;\n  if (type === 'UPDATE') {\n    payload = payload > 11 ? 11 : payload; // upper limit we set\n    const result = fib(payload * 5);\n    self.postMessage({ type: 'UPDATE_SUCCESS', payload: result });\n  }\n});\n\nself.addEventListener(\n  'exit',\n  () => {\n    process.exit(0);\n  },\n  false\n);\n```\n\nWe communicate with the worker using events. Look at the code here, we are listening ðŸ‘‚ to `message` events. We process the data according to `type` passed and return the result as a message.\n\nIf you can guess right, we will have to listen to these messages from the worker in our component. Our component goes like this.\n\n```javascript\n// App.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './styles.css';\n\nconst worker = new Worker('/thread.worker.js');\n\nfunction App() {\n  const [value, setValue] = React.useState('');\n  const [length, setLength] = React.useState(0);\n\n  // when mount and unmount\n  React.useEffect(() => {\n    const listener = ({ data: { type, payload } }) => {\n      console.log(type, payload);\n      if (type === 'UPDATE_SUCCESS') setLength(payload);\n    };\n    worker.addEventListener('message', listener);\n    return () => worker.removeEventListener('message', listener);\n  }, []);\n\n  React.useEffect(() => {\n    worker.postMessage({ type: 'UPDATE', payload: value.length });\n  }, [value]);\n\n  const handleChange = async (e) => {\n    const { value } = e.target;\n    setValue(value);\n  };\n  return (\n    <div className=\"App\">\n      <h1>Hello CodeSandbox</h1>\n      <h2>Start editing to see some magic happen!</h2>\n      <input value={value} onChange={handleChange} />\n      <p>{length}</p>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App />, rootElement);\n```\n\nIf you are using Webpack, you can load it into your component with `worker-loader!thread.js`. We are directly using `Worker()` to load it from the `public` directory.\n\nHere is the codesandbox demo - [https://codesandbox.io/s/funny-nightingale-5kxo1](https://codesandbox.io/s/funny-nightingale-5kxo1)\n\n> Here is the [Effect Hook documentation](https://reactjs.org/docs/hooks-effect.html) for reference.\n\nWe are adding the listeners for the messages in the **first effect**, where the dependencies are `[]`, which means this will [run](https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects) when the component is mounting and unmounting.\n\nAnd in the **second effect**, we send a message to the worker whenever the value changes.\n\nWe can see a huge performance bump with workers when we compare it to the first demo. The load is taken up by the browser now.\n\nThat's how you can use web workers in React. Thanks for reading!\n\nKeep on Hacking! âœŒ\n",
    "code": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var a in e)r(t,a,{get:e[a],enumerable:!0})},i=(t,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!g.call(t,o)&&o!==a&&r(t,o,{get:()=>e[o],enumerable:!(s=p(e,o))||s.enumerable});return t};var b=(t,e,a)=>(a=t!=null?d(m(t)):{},i(e||!t||!t.__esModule?r(a,\"default\",{value:t,enumerable:!0}):a,t)),k=t=>i(r({},\"__esModule\",{value:!0}),t);var h=f((C,c)=>{c.exports=_jsx_runtime});var E={};w(E,{default:()=>x,frontmatter:()=>y});var n=b(h()),y={title:\"Non blocking updates in React\",date:\"2019-07-01\",type:\"Post\",published:!0,description:\"Sometimes, a few updates/computations take up a lot of time. They block the UI from updating, which makes it look as if things are slow.\",tags:\"react,javascript,webworkers\",banner:\"banner.jpg\"};function l(t){let e=Object.assign({p:\"p\",blockquote:\"blockquote\",pre:\"pre\",code:\"code\",strong:\"strong\",em:\"em\",h2:\"h2\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Sometimes, a few updates/computations take up a lot of time. They block the UI from updating, which makes it look as if things are slow. I am not talking about asynchronous data fetches which take time.\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"TL DR; We will be using web workers as a solution along with Hooks.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Consider this for example\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`// Codesandbox - https://codesandbox.io/s/admiring-pond-ixp59\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nconst fib = (i) => (i <= 1 ? i : fib(i - 1) + fib(i - 2));\n\nfunction App() {\n  const [value, setValue] = React.useState('');\n  const [length, setLength] = React.useState(0);\n\n  // whenever \\`value\\` changes\n  React.useEffect(() => {\n    // we calculate the fibonnaci of the length of input * 5\n    const result = fib(value.length * 5);\n    setLength(result);\n  }, [value]);\n\n  const handleChange = async (e) => {\n    const { value } = e.target;\n    setValue(value);\n  };\n  return (\n    <div className=\"App\">\n      <h1>Hello CodeSandbox</h1>\n      <h2>Start editing to see some magic happen!</h2>\n      <input value={value} onChange={handleChange} />\n      <p>{length}</p>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App />, rootElement);\n`})}),`\n`,(0,n.jsx)(e.p,{children:`When we enter the input here, it takes time to update. And it waits for the update to show up until,\ntill the result calculation is not finished. Fibonacci for large numbers is expensive.\nIt even freezes your browser tab if the input is long.`}),`\n`,(0,n.jsxs)(e.p,{children:[\"Do we have a solution to this? Can we some how \",(0,n.jsx)(e.strong,{children:\"off-load\"}),` this computation from the main thread?\n`,(0,n.jsx)(e.em,{children:\"(Why is he talking about threads in javascript?)\"})]}),`\n`,(0,n.jsx)(e.h2,{children:\"Web Workers\"}),`\n`,(0,n.jsx)(e.p,{children:\"Web workers act as threads which are handled/processed by our browser. We can start a worker as a thread and communicate with it in a particular way. React is after all Javascript UI library, and we are running it in the browser, so why not?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is the worker, which has to be statically served. (Put in \",(0,n.jsx)(e.code,{children:\"public\"}),\" folder)\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`// thread.worker.js\nconst fib = (i) => (i <= 1 ? i : fib(i - 1) + fib(i - 2));\n\nself.addEventListener('message', ({ data }) => {\n  let { type, payload } = data;\n  if (type === 'UPDATE') {\n    payload = payload > 11 ? 11 : payload; // upper limit we set\n    const result = fib(payload * 5);\n    self.postMessage({ type: 'UPDATE_SUCCESS', payload: result });\n  }\n});\n\nself.addEventListener(\n  'exit',\n  () => {\n    process.exit(0);\n  },\n  false\n);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We communicate with the worker using events. Look at the code here, we are listening \\u{1F442} to \",(0,n.jsx)(e.code,{children:\"message\"}),\" events. We process the data according to \",(0,n.jsx)(e.code,{children:\"type\"}),\" passed and return the result as a message.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"If you can guess right, we will have to listen to these messages from the worker in our component. Our component goes like this.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`// App.js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './styles.css';\n\nconst worker = new Worker('/thread.worker.js');\n\nfunction App() {\n  const [value, setValue] = React.useState('');\n  const [length, setLength] = React.useState(0);\n\n  // when mount and unmount\n  React.useEffect(() => {\n    const listener = ({ data: { type, payload } }) => {\n      console.log(type, payload);\n      if (type === 'UPDATE_SUCCESS') setLength(payload);\n    };\n    worker.addEventListener('message', listener);\n    return () => worker.removeEventListener('message', listener);\n  }, []);\n\n  React.useEffect(() => {\n    worker.postMessage({ type: 'UPDATE', payload: value.length });\n  }, [value]);\n\n  const handleChange = async (e) => {\n    const { value } = e.target;\n    setValue(value);\n  };\n  return (\n    <div className=\"App\">\n      <h1>Hello CodeSandbox</h1>\n      <h2>Start editing to see some magic happen!</h2>\n      <input value={value} onChange={handleChange} />\n      <p>{length}</p>\n    </div>\n  );\n}\n\nconst rootElement = document.getElementById('root');\nReactDOM.render(<App />, rootElement);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you are using Webpack, you can load it into your component with \",(0,n.jsx)(e.code,{children:\"worker-loader!thread.js\"}),\". We are directly using \",(0,n.jsx)(e.code,{children:\"Worker()\"}),\" to load it from the \",(0,n.jsx)(e.code,{children:\"public\"}),\" directory.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here is the codesandbox demo - \",(0,n.jsx)(e.a,{href:\"https://codesandbox.io/s/funny-nightingale-5kxo1\",children:\"https://codesandbox.io/s/funny-nightingale-5kxo1\"})]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Here is the \",(0,n.jsx)(e.a,{href:\"https://reactjs.org/docs/hooks-effect.html\",children:\"Effect Hook documentation\"}),\" for reference.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We are adding the listeners for the messages in the \",(0,n.jsx)(e.strong,{children:\"first effect\"}),\", where the dependencies are \",(0,n.jsx)(e.code,{children:\"[]\"}),\", which means this will \",(0,n.jsx)(e.a,{href:\"https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects\",children:\"run\"}),\" when the component is mounting and unmounting.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"And in the \",(0,n.jsx)(e.strong,{children:\"second effect\"}),\", we send a message to the worker whenever the value changes.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We can see a huge performance bump with workers when we compare it to the first demo. The load is taken up by the browser now.\"}),`\n`,(0,n.jsx)(e.p,{children:\"That's how you can use web workers in React. Thanks for reading!\"}),`\n`,(0,n.jsx)(e.p,{children:\"Keep on Hacking! \\u270C\"})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var x=v;return k(E);})();\n;return Component;"
  },
  "_id": "writings/non-blocking-ui-react/index.mdx",
  "_raw": {
    "sourceFilePath": "writings/non-blocking-ui-react/index.mdx",
    "sourceFileName": "index.mdx",
    "sourceFileDir": "writings/non-blocking-ui-react",
    "contentType": "mdx",
    "flattenedPath": "writings/non-blocking-ui-react"
  },
  "type": "Post",
  "slug": "/writings/non-blocking-ui-react"
}